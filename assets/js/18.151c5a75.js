(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{185:function(t,a,s){"use strict";s.r(a);var r=s(0),e=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"服务端渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染","aria-hidden":"true"}},[t._v("#")]),t._v(" 服务端渲染")]),t._v(" "),s("h3",{attrs:{id:"客户端渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#客户端渲染","aria-hidden":"true"}},[t._v("#")]),t._v(" 客户端渲染")]),t._v(" "),s("p",[t._v("客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{attrs:{class:"token operator"}},[t._v("<")]),s("span",{attrs:{class:"token operator"}},[t._v("!")]),t._v("doctype html"),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v("html"),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),s("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v("head"),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),s("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v("title"),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v("我是客户端渲染的页面"),s("span",{attrs:{class:"token operator"}},[t._v("<")]),s("span",{attrs:{class:"token operator"}},[t._v("/")]),t._v("title"),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),s("span",{attrs:{class:"token operator"}},[t._v("<")]),s("span",{attrs:{class:"token operator"}},[t._v("/")]),t._v("head"),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),s("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v("body"),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),s("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v("div id"),s("span",{attrs:{class:"token operator"}},[t._v("=")]),s("span",{attrs:{class:"token string"}},[t._v("'root'")]),s("span",{attrs:{class:"token operator"}},[t._v(">")]),s("span",{attrs:{class:"token operator"}},[t._v("<")]),s("span",{attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),s("span",{attrs:{class:"token operator"}},[t._v("<")]),t._v("script src"),s("span",{attrs:{class:"token operator"}},[t._v("=")]),s("span",{attrs:{class:"token string"}},[t._v("'index.js'")]),s("span",{attrs:{class:"token operator"}},[t._v(">")]),s("span",{attrs:{class:"token operator"}},[t._v("<")]),s("span",{attrs:{class:"token operator"}},[t._v("/")]),t._v("script"),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),s("span",{attrs:{class:"token operator"}},[t._v("<")]),s("span",{attrs:{class:"token operator"}},[t._v("/")]),t._v("body"),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{attrs:{class:"token operator"}},[t._v("<")]),s("span",{attrs:{class:"token operator"}},[t._v("/")]),t._v("html"),s("span",{attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("h3",{attrs:{id:"服务端渲染-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染-2","aria-hidden":"true"}},[t._v("#")]),t._v(" 服务端渲染")]),t._v(" "),s("p",[t._v("服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。")]),t._v(" "),s("p",[t._v("使用服务端渲染的网站，可以说是“所见即所得”，"),s("strong",[t._v("页面上呈现的内容，我们在 html 源文件里也能找到")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"服务端渲染解决的性能问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染解决的性能问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 服务端渲染解决的性能问题")]),t._v(" "),s("p",[t._v("索引擎只会查找现成的内容，不会帮你跑 JS 代码。A 网站的运营方见此情形，感到很头大：搜索引擎搜不出来，用户找不到我们，谁还会用我的网站呢？为了把“现成的内容”拿给搜索引擎看，A 网站不得不启用服务端渲染。")]),t._v(" "),s("p",[t._v("但性能在其次，不代表性能不重要。服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢。在客户端渲染模式下，我们除了加载 HTML，还要等渲染所需的这部分 JS 加载完，之后还得把这部分 JS 在浏览器上再跑一遍。这一切都是发生在用户点击了我们的链接之后的事情，在这个过程结束之前，用户始终见不到我们网页的庐山真面目，也就是说用户一直在等！相比之下，服务端渲染模式下，服务器给到客户端的已经是一个直接可以拿来呈现给用户的网页，中间环节早在服务端就帮我们做掉了")]),t._v(" "),s("p",[t._v("react,vue项目强调的只有两点：一是这个 renderToString() 方法；二是把转化结果“塞”进模板里的这一步。这两个操作是服务端渲染的灵魂操作。在虚拟 DOM“横行”的当下，服务端渲染不再是早年 JSP 里简单粗暴的字符串拼接过程，它还要求这一端要具备将虚拟 DOM 转化为真实 DOM 的能力。与其说是“把 JS 在服务器上先跑一遍”，不如说是“把 Vue、React 等框架代码先在 Node 上跑一遍”。")]),t._v(" "),s("h2",{attrs:{id:"服务端渲染的应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染的应用场景","aria-hidden":"true"}},[t._v("#")]),t._v(" 服务端渲染的应用场景")]),t._v(" "),s("p",[t._v("几乎有多少个用户就有多少台浏览器。用户拥有的浏览器总量多到数不清，那么一个公司的服务器又有多少台呢？我们把这么多台浏览器的渲染压力集中起来，分散给相比之下数量并不多的服务器，服务器肯定是承受不住的。")]),t._v(" "),s("p",[t._v("在实践中，我一般会建议大家先忘记服务端渲染这个事情——服务器稀少而宝贵，但首屏渲染体验和 SEO 的优化方案却很多——我们最好先把能用的低成本“大招”都用完。除非网页对性能要求太高了，以至于所有的招式都用完了，性能表现还是不尽人意，这时候我们就可以考虑向老板多申请几台服务器，把服务端渲染搞起来了~")])])}],!1,null,null,null);e.options.__file="SSR.md";a.default=e.exports}}]);